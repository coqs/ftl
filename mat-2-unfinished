# your comments are still here
# Turn() - for turning a specific angle, can be used for zigzag lines or 90-degree turns
# lfStopBlue() - stops once either of the color sensors is blue
# lfDistance() - line follows for a distance
# lfwaitturnLR90 - keeps following line until left or right line detect then aligns (turns 90 degrees) to that line (only use for left or right lanes/lines)
# lfwaitturnLR45 - same as above but turns 45 degrees instead, good for zigzags!!!
#

from pybricks.hubs import PrimeHub
from pybricks.pupdevices import Motor, ColorSensor, UltrasonicSensor, ForceSensor
from pybricks.parameters import Button, Color, Direction, Port, Side, Stop
from pybricks.robotics import DriveBase
from pybricks.tools import wait, StopWatch

hub = PrimeHub()

# motors and sensors
leftMtr = Motor(port=Port.E, positive_direction=Direction.COUNTERCLOCKWISE)
rightMtr = Motor(port=Port.F, positive_direction=Direction.CLOCKWISE)
leftSnsr = ColorSensor(Port.C)
rightSnsr = ColorSensor(Port.D)
distanceSensor = UltrasonicSensor(port=Port.B)

# pid gains - tune these for your robot
kp = 0.933
ki = 0.002
kd = 1.77
gyro_kp = 1 # for the gyro straight function

# pid state variables
integral = 0
last_error = 0
lr = None

distancestuff = 56
wheelDiameter = 56

dbRobot = DriveBase(left_motor=leftMtr, right_motor=rightMtr, wheel_diameter=wheelDiameter, axle_track=119.5)

# --- core pid and movement logic ---

def reset_pid():
    # gotta reset the pid brain before each new move
    global integral, last_error
    integral = 0
    last_error = 0

def do_pid_step(speed):
    # this is the main pid calculation
    global integral, last_error, ki, kp, kd
    error = leftSnsr.reflection() - rightSnsr.reflection()
    integral += error
    # this stops the integral from getting too huge if the robot gets lost
    if abs(integral) > 1000:
        if integral > 0:
            integral = 1000
        else:
            integral = -1000
    derivative = error - last_error
    turn_rate = (kp * error) + (ki * integral) + (kd * derivative)
    dbRobot.drive(speed, turn_rate)
    last_error = error

def go_straight_gyro(distance_mm: float, speed: int):
    # this is just for moving straight accurately, used by the spin turn now
    dbRobot.reset()
    hub.imu.reset_heading(0)
    while dbRobot.distance() < distance_mm:
        correction = hub.imu.heading() * gyro_kp
        dbRobot.drive(speed, -correction)
    dbRobot.stop()

def Turn(angle: int, speed: int, pivot: bool = False, adjust_on_line: bool = True):

    wait(0.1)

    direction = 1 if angle > 0 else -1

    if not pivot:
        # Move forward slightly to center robot on junction before turning
        dbRobot.straight(distance=distancestuff, then=Stop.HOLD, wait=True)
        dbRobot.turn(angle)

    else:
        target = abs(angle)
        base_speed = abs(speed)
        while True:
            current = abs(hub.imu.heading())
            remaining = target - current

            # Slow down as we get close to the target angle
            if remaining < 1:
                cur_speed = base_speed * 1
            elif remaining < 15:
                cur_speed = base_speed * 1.2
            else:
                cur_speed = base_speed

            # Run motors depending on pivot direction
            if direction > 0:  # Right pivot
                rightMtr.hold()
                leftMtr.run(-cur_speed)
            else:               # Left pivot
                leftMtr.hold()
                rightMtr.run(cur_speed)

            if current >= target:
                break
            wait(1)

        leftMtr.hold()
        rightMtr.hold()

    dbRobot.stop()
    wait(1)

    # --- Optional final line alignment ---
    if adjust_on_line:
        reset_pid()
        timer = StopWatch()
        while timer.time() < 160:  # for about 1 second
            # keep following until one sensor sees black or white properly
            if leftSnsr.color() == Color.BLACK or rightSnsr.color() == Color.BLACK:
                break
            do_pid_step(speed * 0.81)
        dbRobot.stop()



# --- your functions now clean and using the right logic ---

def lfStopBlue(speed: int) -> None:
    reset_pid()
    while leftSnsr.color() != Color.BLUE and rightSnsr.color() != Color.BLUE:
        do_pid_step(speed)
    # stops exactly on the blue line now, no extra movement
    dbRobot.stop()

def lfDistance(speed: int, distance: float) -> None:
    reset_pid()
    dbRobot.reset()
    target_mm = distance * 10
    while dbRobot.distance() < target_mm:
        do_pid_step(speed)
    dbRobot.stop()


def lfWaitTurnLR90(speed: int) -> None:
    reset_pid()
    dbRobot.reset()
    while dbRobot.distance() < 20:
        do_pid_step(speed)

    while leftSnsr.color() != Color.BLUE and rightSnsr.color() != Color.BLUE:
        do_pid_step(speed)
    dbRobot.stop()
    
    if leftSnsr.color() == Color.BLUE:
        lr = "L"
    else:
        lr = "R"
    
    # now we just call the turn function it handles the rest
    if lr == "L":
        Turn(angle=-90, speed=speed, pivot=True)
    else:
        Turn(angle=90, speed=speed, pivot=True)

def lfWaitTurnLR45(speed: int) -> None:
    reset_pid()
    dbRobot.reset()
    while dbRobot.distance() < 20:
        do_pid_step(speed)
        
    while leftSnsr.color() != Color.BLUE and rightSnsr.color() != Color.BLUE:
        do_pid_step(speed)
    dbRobot.stop()
    
    if leftSnsr.color() == Color.BLUE:
        lr = "L"
    else:
        lr = "R"

    if lr == "L":
        Turn(angle=-45, speed=speed, pivot=True)
    else:
        Turn(angle=45, speed=speed, pivot=True)
        
def lfWaitBlueLine(speed: int, startcm: float, stopCondition: str) -> None:
    lfDistance(speed=speed, distance=startcm)
    
    reset_pid()
    stop = None
    while stop != stopCondition:
        do_pid_step(speed)
        
        is_left_blue = leftSnsr.color() == Color.BLUE
        is_right_blue = rightSnsr.color() == Color.BLUE

        if is_left_blue and is_right_blue:
            stop = "B"
        elif is_left_blue:
            stop = "L"
        elif is_right_blue:
            stop = "R"

    # stops exactly where it sees the line
    dbRobot.brake()

def lfStopBarrier(speed: int, barrierDistance: float) -> None:
    reset_pid()
    barrierDistanceMM = barrierDistance * 10
    while distanceSensor.distance() > barrierDistanceMM:
        do_pid_step(speed)
    dbRobot.stop()

def pivotTurn(slowWheelSpeed: int, fastWheelSpeed: int, angle: float, endAlignCM: float) -> None:
    hub.imu.reset_heading(angle=0)

    if angle > 0:
        while hub.imu.heading() < angle:
            leftMtr.run(speed=fastWheelSpeed)
            rightMtr.run(speed=slowWheelSpeed)
    elif angle < 0:
        while abs(hub.imu.heading()) < abs(angle):
            leftMtr.run(speed=slowWheelSpeed)
            rightMtr.run(speed=fastWheelSpeed)

    leftMtr.hold()
    rightMtr.hold()
    lfDistance(speed=slowWheelSpeed, distance=endAlignCM * 10)

def half_circle(radius_mm: int, speed_mm_s: int = 150, clockwise: bool = True) -> None:
    """
    Drive a perfect 180° arc (half-circle) using DriveBase.curve().
    - radius_mm: distance from robot center to arc center (mm)
    - speed_mm_s: linear speed of the robot (mm/s)
    - clockwise: True → right-hand arc, False → left-hand arc
    """
    angle = 180 if clockwise else -180
    dbRobot.curve(radius_mm, angle, Stop.BRAKE, True)

def turnAroundBarrier(leftORright: str) -> None:
    if leftORright == "L":
        dbRobot.curve(0, -50, Stop.HOLD, True)
        dbRobot.curve(380, 45, Stop.HOLD, True)
        dbRobot.curve(0, 65, Stop.HOLD, True)
        lfWaitBlueLine(150, 0, "R")
        dbRobot.straight(73, Stop.HOLD, True)
        dbRobot.curve(0, -60, Stop.HOLD, True)
    else:  # right
        dbRobot.curve(0, 50, Stop.HOLD, True)
        dbRobot.curve(380, -45, Stop.HOLD, True)
        dbRobot.curve(0, -65, Stop.HOLD, True)
        lfWaitBlueLine(150, 0, "L")
        dbRobot.straight(73, Stop.HOLD, True)
        dbRobot.curve(0, 80, Stop.HOLD, True)



def mainFunc() -> None:
    speedrunMS = StopWatch()
    speedrunMS.reset()
    global kp, ki, kd
    kp = 1.35
    kd = 0
    

    lfWaitBlueLine(350, 1, stopCondition="L")
    dbRobot.curve(40, -96, Stop.BRAKE, True)

    lfWaitBlueLine(350, 1, stopCondition="R")
    dbRobot.curve(40, 96, Stop.BRAKE, True)

    lfWaitBlueLine(350, 1, stopCondition="R")
    dbRobot.curve(40, 96, Stop.BRAKE, True)

    lfStopBarrier(300, 12)
    Turn(-90, 500, False, False)
    half_circle(130, 100, True)
    dbRobot.straight(30, Stop.BRAKE, True)
    dbRobot.curve(0, -87, Stop.BRAKE, True)

    lfWaitBlueLine(350, 1, stopCondition="R")
    Turn(90, 500, False, False)

    kp = 1.65
    lfDistance(250, 15)
    lfWaitBlueLine(250, 0, "L")
    dbRobot.curve(40, -93, Stop.HOLD, True)




    print(speedrunMS.time())

mainFunc()
